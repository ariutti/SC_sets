// 1.create a group to put all the carrier synths inside
~grp_vocoders  = Group.new( ~verb, \addAfter);
//~grp_vocoders  = Group.new( s, \addToTail); //alternative

~grp_vocoders.moveNodeToHead(~verb);
~grp_vocoders.moveNodeToTail(~verb);

// 2. create a bus to connect the modulator synth to the carrier synths
~bus_modulator = Bus.audio(s,1);

~bus_modulator.scope;
~bus_modulator.free;
s.plotTree;

// external input ///////////////////////////////////////////////////////////////////////
// 3. define a synth for getting sound in from the sound card

(
SynthDef(\inMic, {
	|
	out=0, in=0, amp=1.0
	//gate parameters
	gth    = -22, // dB
	gslope = 7.0,
	//compressor parameters
	cth    = -12, // dB
	cslope = 5.0,
	// filter parameters
	cf = 110
	|
	var sig = SoundIn.ar( in );
	// Noise Gate
	sig = Compander.ar(sig, sig, gth.dbamp, slopeBelow:gslope );
	// Compressor
	sig = Compander.ar(sig, sig, cth.dbamp, slopeAbove:1/cslope );
	// high pass filter
	sig = HPF.ar(sig, cf);
	// MakeUp gain sort-of
	sig = Normalizer.ar(sig) * amp;
	Out.ar(out, sig);
}).add;
)


~synth_voc_modulator = Synth(\inMic, [\amp, 0.5, \out, ~bus_modulator], addAction:\addToHead);
//~voc_modulator = Synth(\in, [\amp, 0.7, \out, 0], addAction:\addToHead);
~synth_voc_modulator.set(\amp, 0.9);
~synth_voc_modulator.set(\g_slope, 9.0);
~synth_voc_modulator.free;


~notes = Array.newClear(128); // an array to store Synth refs


// define a vocoder synth which will use:
// * an external input as the modulator source;
// * a wavetable synth for the carrier;
(
SynthDef(\vocoder_synth_wt, {
	|
	out=0, in=2, amp=1.0, freq=440,
	atk=0.1, dcy=0.1, sus=0.7, rel=1,
	width=0.5, pan=0.0, bufnum, gate=1
	|
	var sig, env, chainMod, chainCarr, chain, input;
	env = EnvGen.ar(Env.adsr(atk, dcy, sus, rel), gate, doneAction:2);
	sig = Osc.ar(bufnum, freq);
	input = In.ar(in,1) * env;

	chainMod = FFT(LocalBuf(1024), input);
	chainMod = PV_MagAbove(chainMod, 0.2);
    chainCarr = FFT(LocalBuf(1024), sig);
    chain  = PV_MagMul(chainCarr, chainMod);
	chain = PV_MagClip(chain, 50);

	sig = IFFT(chain);
	sig = sig * amp;

	sig = LeakDC.ar(sig);
	Out.ar(sig, Pan2.ar(sig, pan));
}).add;
)


// WAVETABLE ////////////////////////////////////////////////////////////////////////////
// instantiate the buffer
~buffer_wt = Buffer.alloc(s, 2048);
// fill the buffer
(
var env, sig, wt;
var nseg = rrand(2, 15);
env = Env(
	[0.0] ++
	(({rrand(0.0, 1.0)})!(nseg-1) * [1,-1]).scramble ++
	[0.0],
	{rrand(0.01, 0.99)}!nseg,
	{rrand(-20.0, 20.0)}!nseg
);
sig = env.asSignal(1024);
wt = sig.asWavetable;
//wt.plot;
~buffer_wt.loadCollection(wt);
wt.size.postln;
~buffer_wt.normalize(1, asWavetable: true);
)

// MIDI ////////////////////////////////////////////////////////////////////////////////
MIDIClient.init;
MIDIIn.connectAll;

~vocoder_volume = 1;

(
MIDIdef.noteOn(\noteOnDef, {
	arg vel, note, ch, src;
	[note, vel, "on"].postln;
	~notes[note] = Synth.new(\vocoder_synth_wt, [
		\freq, note.midicps,
		\amp, vel.explin(1, 127, 0.001, 0.5) * ~vocoder_volume,
		\pan, rrand(-1.0, 1.0),
		\bufnum, ~buffer_wt,
		\gate, 1,
		\in, ~bus_modulator
	],~grp_vocoders);
}, chan:0);

MIDIdef.noteOff(\noteOffDef, {
	arg vel, note, ch, src;
	[note, vel, "off"].postln;
	~notes[note].set(\gate, 0);
	~notes[note] = nil;
}, chan:0);
)

// MIDI PANIC sort-of
// this is actually a way to free any stucked synth generated by MIDI note on messages
(
Pbindef(\vocoder_chords).stop;
~grp_vocoders.freeAll;
)
~grp_vocoders.free;

// AUTOMATIC CARRIER GENERATION //////////////////////////////////////////////////////


// skyline (aka rubarb)
(
Pbindef(\vocoder_chords,
	\instrument, \vocoder_synth_wt,
	\scale, Scale.major,
	\octave, Prand([4,5], inf),
	\root, 5,
	\mtranspose, Pwhite(0.0, 0.025, inf),
	\degree, Pseq([
		Pn(Prand([3,5,7],8), 1), // Bb
		Pn(Prand([0,4,7],8), 1), // F
		//Pn(Prand([1,3,5],8), 1), // Gm
		//Pn(Prand([0,4,7],8), 1), // F
	], inf),
	\width, 0.01, //Pwhite(0.01, 0.5, inf),
	\in, ~bus_modulator,
	\atk, 0.5,
	\rel, 1,
	\amp, 0.125,
	\bufnum, ~buffer_wt,
	\dur, Pseq([0.25], inf),
	\group, ~grp_vocoders,
	\pan, Pwhite(-1.0, 1.0, inf).clump(4)
).quant_([4]).play;
)
Pbindef(\vocoder_chords).stop;




// skyline (aka rubarb)
(
Pbindef(\chords,
	\instrument, \vocoder_synth_wt,
	\scale, Scale.minor,
	\root, 1,
	\octave, Prand([[4,5,6,7]], inf).clump(4),
	\degree, Prand([ [0,2,4,7] ], inf),
	\mtranspose, Pwhite(-0.03, 0.03, inf).clump(4),
	\width, 0.01, //Pwhite(0.01, 0.5, inf),
	\in, ~bus_modulator,
	\atk, 0.5,
	\rel, 1,
	\amp, 0.125,
	\bufnum, ~buffer_wt,
	\dur, Pseq([Pn(0.25,8)], inf),
	\group, ~grp_vocoders,
	\pan, Pwhite(-1.0, 1.0, inf).clump(4)
).quant_([4]).play;
)
Pbindef(\chords).stop;
Pbindef(\chords).clear;


Pbindef(\chords, \degree, 0 + Prand([ [0,1,2] ], inf));
Pbindef(\chords, \degree, -1 + Prand([ [0,1,2] ], inf));
Pbindef(\chords, \degree, -2 + Prand([ [0,1,2] ], inf));
Pbindef(\chords, \degree, Prand([ [-1,0,2] ], inf));
Pbindef(\chords, \degree, Prand([ [0,2,3,6] ], inf));