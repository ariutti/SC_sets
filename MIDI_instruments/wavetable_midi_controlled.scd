/*
* This sketch uses MIDI "noteOn" messages
* coming in to play some sounds
* using a SynthDef
*/

s.boot;

MIDIClient.init;
MIDIIn.connectAll;

~notes = Array.newClear(128); // an array to store Synth refs
~midinotes_grp = Group(s);


(
SynthDef(\wt_simple, {
	|amp=0, out=0, bufnum, freq=440, atk=0.01, dcy=0.1, sus=0.7, rel=1, pan=0.0, gate=1|
	var env = EnvGen.ar(Env.adsr(atk, dcy, sus, rel), gate, doneAction:2);
	var sig = Osc.ar(bufnum, freq);
	sig = sig * env * amp;
	sig = LeakDC.ar(sig);
	Out.ar(out, Pan2.ar(sig, pan));
}).add;
)


b = Buffer.alloc(s, 2048);
(
var env, sig, wt;
var nseg = rrand(2, 15);
env = Env(
	[0.0] ++
	(({rrand(0.0, 1.0)})!(nseg-1) * [1,-1]).scramble ++
	[0.0],
	{rrand(0.01, 0.99)}!nseg,
	{rrand(-20.0, 20.0)}!nseg
);
sig = env.asSignal(1024);
wt = sig.asWavetable;
//wt.plot;
b.loadCollection(wt);
wt.size.postln;
b.normalize(1, asWavetable: true);
)


(
MIDIdef.noteOn(\noteOnDef, {
	arg vel, note, ch, src;
	[note, vel, "on"].postln;
	~notes[note] = Synth.new(\wt_simple, [
		\freq, note.midicps,
		\amp, vel.explin(1, 127, 0.001, 0.5),
		\pan, rrand(-1.0, 1.0),
		\bufnum, b,
		\gate, 1
	],~midinotes_grp);
}, chan:0);

MIDIdef.noteOff(\noteOffDef, {
	arg vel, note, ch, src;
	[note, vel, "off"].postln;
	~notes[note].set(\gate, 0);
	~notes[note] = nil;
}, chan:0);
)
// MIDI panic sort of
// this is actually a way to free any stucked synth generated by MIDI note on messages
~midinotes_grp.freeAll;
~midinotes_grp.freeAll;
~midinotes_grp.free

(
a = Synth.basicNew(\susSynth, nodeID:1800);
a.free;
)